#ifndef TEST_H
#define TEST_H
#include <gtest/gtest.h>

#include <fcntl.h>
#include <errno.h>
#include <unistd.h>

//char maze[15][15];
extern char maze[15][15];
#include<func.h>
extern player igrok;
extern bool win;


//Модульные тесты

TEST(modalPositiveTest,initMaze) {
    char mazeTrue[15][15] = {
        {'#','#','#','#','#','#','#','#','#','#','#','#','#','#','#'},
        {'#','.','#','.','#','.','#','.','#','.','#','.','#','.','#'},
        {'#','#','#','#','#','#','#','#','#','#','#','#','#','#','#'},
        {'#','.','#','.','#','.','#','.','#','.','#','.','#','.','#'},
        {'#','#','#','#','#','#','#','#','#','#','#','#','#','#','#'},
        {'#','.','#','.','#','.','#','.','#','.','#','.','#','.','#'},
        {'#','#','#','#','#','#','#','#','#','#','#','#','#','#','#'},
        {'#','.','#','.','#','.','#','.','#','.','#','.','#','.','#'},
        {'#','#','#','#','#','#','#','#','#','#','#','#','#','#','#'},
        {'#','.','#','.','#','.','#','.','#','.','#','.','#','.','#'},
        {'#','#','#','#','#','#','#','#','#','#','#','#','#','#','#'},
        {'#','.','#','.','#','.','#','.','#','.','#','.','#','.','#'},
        {'#','#','#','#','#','#','#','#','#','#','#','#','#','#','#'},
        {'#','.','#','.','#','.','#','.','#','.','#','.','#','.','#'},
        {'#','#','#','#','#','#','#','#','#','#','#','#','#','#','#'},
                            };
    init_maze();
    bool res = true;
    for(int i = 0; i < width; i++){
        for(int j = 0; j < height; j++){
            if(maze[i][j] != mazeTrue[i][j]){
                res = false;
            }
        }
    }
    ASSERT_EQ(res, true);

}

TEST(modalPositiveTest,removeWall) {
    char mazeTrue[15][15] = {
        {'#','#','#','#','#','#','#','#','#','#','#','#','#','#','#'},
        {'#','.','#','.','#','.','#','.','#','.','#','.','#','.','#'},
        {'#','#','#','#','#','#','#','#','#','#','#','#','#','#','#'},
        {'#','.','#','.','#','.','#','.','#','.','#','.','#','.','#'},
        {'#','#','#','#','#','#','#','#','#','#','#','#','#','#','#'},
        {'#','.','#','.','#','.','#','.','#','.','#','.','#','.','#'},
        {'#','#','#','#','#','#','#','#','#','#','#','#','#','#','#'},
        {'#','.','#','.','#','.','#','.','#','.','#','.','#','.','#'},
        {'#','#','#','#','#','#','#','#','#','#','#','#','#','#','#'},
        {'#','.','#','.','#','.','#','.','#','.','#','.','#','.','#'},
        {'#','#','#','#','#','#','#','#','#','#','#','#','#','#','#'},
        {'#','.','#','.','#','.','#','.','#','.','#','.','#','.','#'},
        {'#','#','#','#','#','#','#','#','#','#','#','#','#','#','#'},
        {'#','.','#','.','#','.','#','.','#','.','#','.','#','.','#'},
        {'#','#','#','#','#','#','#','#','#','#','#','#','#','#','#'},
                            };
    removeWall({1,1},{3,1}, mazeTrue);
    ASSERT_EQ(mazeTrue[1][2], VISITED);

}


TEST(modalPositiveTest,getNeighbours) {
    char mazeTrue[15][15] = {
        {'#','#','#','#','#','#','#','#','#','#','#','#','#','#','#'},
        {'#','.','#','.','#','.','#','.','#','.','#','.','#','.','#'},
        {'#','#','#','#','#','#','#','#','#','#','#','#','#','#','#'},
        {'#','.','#','.','#','.','#','.','#','.','#','.','#','.','#'},
        {'#','#','#','#','#','#','#','#','#','#','#','#','#','#','#'},
        {'#','.','#','.','#','.','#','.','#','.','#','.','#','.','#'},
        {'#','#','#','#','#','#','#','#','#','#','#','#','#','#','#'},
        {'#','.','#','.','#','.','#','.','#','.','#','.','#','.','#'},
        {'#','#','#','#','#','#','#','#','#','#','#','#','#','#','#'},
        {'#','.','#','.','#','.','#','.','#','.','#','.','#','.','#'},
        {'#','#','#','#','#','#','#','#','#','#','#','#','#','#','#'},
        {'#','.','#','.','#','.','#','.','#','.','#','.','#','.','#'},
        {'#','#','#','#','#','#','#','#','#','#','#','#','#','#','#'},
        {'#','.','#','.','#','.','#','.','#','.','#','.','#','.','#'},
        {'#','#','#','#','#','#','#','#','#','#','#','#','#','#','#'},
                            };
    cellString test = getNeighbours(mazeTrue, {1,1});
    cellString test1;
    test1.cells[0] = {1,3};
    test1.cells[1] = {3,1};
    bool res = true;
    for(int i = 0; i < 2; i++){
        if (test.cells[i].x != test1.cells[i].x || test.cells[i].y != test1.cells[i].y){
            res = false;
        }
        }
    if(test.size != 2){
        res = false;
    }
    ASSERT_EQ(res,1);

}


TEST(modalPositiveTest,unvisitedCount) {
    char mazeTrue[15][15] = {
        {'#','#','#','#','#','#','#','#','#','#','#','#','#','#','#'},
        {'#','.','#','.','#','.','#','.','#','.','#','.','#','.','#'},
        {'#','#','#','#','#','#','#','#','#','#','#','#','#','#','#'},
        {'#','.','#','.','#','.','#','.','#','.','#','.','#','.','#'},
        {'#','#','#','#','#','#','#','#','#','#','#','#','#','#','#'},
        {'#','.','#','.','#','.','#','.','#','.','#','.','#','.','#'},
        {'#','#','#','#','#','#','#','#','#','#','#','#','#','#','#'},
        {'#','.','#','.','#','.','#','.','#','.','#','.','#','.','#'},
        {'#','#','#','#','#','#','#','#','#','#','#','#','#','#','#'},
        {'#','.','#','.','#','.','#','.','#','.','#','.','#','.','#'},
        {'#','#','#','#','#','#','#','#','#','#','#','#','#','#','#'},
        {'#','.','#','.','#','.','#','.','#','.','#','.','#','.','#'},
        {'#','#','#','#','#','#','#','#','#','#','#','#','#','#','#'},
        {'#','.','#','.','#','.','#','.','#','.','#','.','#','.','#'},
        {'#','#','#','#','#','#','#','#','#','#','#','#','#','#','#'},
                            };

    //49
    int countTest = unvisitedCount(mazeTrue);

    ASSERT_EQ(countTest,49);

}

//Интеграционные тесты
TEST(test,generateStep) {
    for(int i = 0; i < height; i++){
            for(int j = 0; j < width; j++){
                if((i % 2 != 0  && j % 2 != 0) && //если ячейка нечетная по x и y,
                   (i < height-1 && j < width-1))   //и при этом находится в пределах стен лабиринта
                       maze[i][j] = CELL;       //то это КЛЕТКА
                else maze[i][j] = WALL;           //в остальных случаях это СТЕНА.
            }
        }
    //ASSERT_EQ(countTest,49);

    //Проверить generateStep()
    generate_step();

    bool res = false;
    if((maze[1][1] == VISITED && maze[1][2] == VISITED && maze[1][3] == VISITED) || (maze[1][1] == VISITED && maze[2][1] == VISITED && maze[3][1] == VISITED)){
        res = true;
    }
    ASSERT_EQ(res,1);
}


   // Проверить movementPLayer()
   // 4 позитивных и 4 негативных(Для каждой кнопки)
   //Проверить когда при переходе попадаем на победную клетку!

   // Негативный тест(если стенка и игрок пвтается туда пойти)


TEST(modalPositiveTest,movementPlayerDandWin) {
    for(int i = 0; i < height; i++){
            for(int j = 0; j < width; j++){
                if(j == 0 || j == 14 || i == 0 || i == 14){
                    maze[i][j] = WALL;
                }
                else maze[i][j] = VISITED;
            }
        }
    igrok.current_player_pos = {13,12};

    //maze[igrok.current_player_pos.x][igrok.current_player_pos.y] = '@';
    movementPlayer(100);
    ASSERT_EQ(win,true);
}

TEST(modalPositiveTest,movementPlayerSandWin) {
    for(int i = 0; i < height; i++){
            for(int j = 0; j < width; j++){
                if(j == 0 || j == 14 || i == 0 || i == 14){
                    maze[i][j] = WALL;
                }
                else maze[i][j] = VISITED;
            }
        }
    igrok.current_player_pos = {12,13};

    //maze[igrok.current_player_pos.x][igrok.current_player_pos.y] = '@';
    movementPlayer(115);
    ASSERT_EQ(win,true);
}

TEST(modalPositiveTest,movementPlayerW) {
    for(int i = 0; i < height; i++){
            for(int j = 0; j < width; j++){
                if(j == 0 || j == 14 || i == 0 || i == 14){
                    maze[i][j] = WALL;
                }
                else maze[i][j] = VISITED;
            }
        }
    igrok.current_player_pos = {2,2};

    maze[igrok.current_player_pos.x][igrok.current_player_pos.y] = '@';
    movementPlayer(119);
    int res = 0;
    if(igrok.current_player_pos.x == 1 && igrok.current_player_pos.y == 2){
        res = 1;
    }

    ASSERT_EQ(res,1);
}

TEST(modalPositiveTest,movementPlayerD) {
    for(int i = 0; i < height; i++){
            for(int j = 0; j < width; j++){
                if(j == 0 || j == 14 || i == 0 || i == 14){
                    maze[i][j] = WALL;
                }
                else maze[i][j] = VISITED;
            }
        }
    igrok.current_player_pos = {2,2};

    maze[igrok.current_player_pos.x][igrok.current_player_pos.y] = '@';
    movementPlayer(100);
    int res = 0;
    if(igrok.current_player_pos.x == 2 && igrok.current_player_pos.y == 3){
        res = 1;
    }

    ASSERT_EQ(res,1);
}

TEST(modalPositiveTest,movementPlayerA) {
    for(int i = 0; i < height; i++){
            for(int j = 0; j < width; j++){
                if(j == 0 || j == 14 || i == 0 || i == 14){
                    maze[i][j] = WALL;
                }
                else maze[i][j] = VISITED;
            }
        }
    igrok.current_player_pos = {2,2};

    maze[igrok.current_player_pos.x][igrok.current_player_pos.y] = '@';
    movementPlayer(97);
    int res = 0;
    if(igrok.current_player_pos.x == 2 && igrok.current_player_pos.y == 1){
        res = 1;
    }

    ASSERT_EQ(res,1);
}

TEST(modalPositiveTest,movementPlayerS) {
    for(int i = 0; i < height; i++){
            for(int j = 0; j < width; j++){
                if(j == 0 || j == 14 || i == 0 || i == 14){
                    maze[i][j] = WALL;
                }
                else maze[i][j] = VISITED;
            }
        }
    igrok.current_player_pos = {2,2};

    maze[igrok.current_player_pos.x][igrok.current_player_pos.y] = '@';
    movementPlayer(115);
    int res = 0;
    if(igrok.current_player_pos.x == 3 && igrok.current_player_pos.y == 2){
        res = 1;
    }

    ASSERT_EQ(res,1);
}

TEST(modalNegativeTest,removeWall) {
    char mazeTrue[15][15] = {
        {'#','#','#','#','#','#','#','#','#','#','#','#','#','#','#'},
        {'#','.','#','.','#','.','#','.','#','.','#','.','#','.','#'},
        {'#','#','#','#','#','#','#','#','#','#','#','#','#','#','#'},
        {'#','.','#','.','#','.','#','.','#','.','#','.','#','.','#'},
        {'#','#','#','#','#','#','#','#','#','#','#','#','#','#','#'},
        {'#','.','#','.','#','.','#','.','#','.','#','.','#','.','#'},
        {'#','#','#','#','#','#','#','#','#','#','#','#','#','#','#'},
        {'#','.','#','.','#','.','#','.','#','.','#','.','#','.','#'},
        {'#','#','#','#','#','#','#','#','#','#','#','#','#','#','#'},
        {'#','.','#','.','#','.','#','.','#','.','#','.','#','.','#'},
        {'#','#','#','#','#','#','#','#','#','#','#','#','#','#','#'},
        {'#','.','#','.','#','.','#','.','#','.','#','.','#','.','#'},
        {'#','#','#','#','#','#','#','#','#','#','#','#','#','#','#'},
        {'#','.','#','.','#','.','#','.','#','.','#','.','#','.','#'},
        {'#','#','#','#','#','#','#','#','#','#','#','#','#','#','#'},
                            };
    int res;
    res = removeWall({15,1},{3,1}, mazeTrue);
    ASSERT_EQ(res, -1);
}

TEST(modalNegativeTest,initMaze) {
    char mazeNotTrue[15][15] = {
        {'#','#','#','#','#','#','#','#','#','#','#','#','#','#','#'},
        {'#','#','#','.','#','.','#','.','#','.','#','.','#','.','#'},
        {'#','#','#','#','#','#','#','#','#','#','#','#','#','#','#'},
        {'#','.','#','.','#','.','#','.','#','.','#','.','#','.','#'},
        {'#','#','#','#','#','#','#','#','#','#','#','#','#','#','#'},
        {'#','.','#','.','#','.','#','.','#','.','#','.','#','.','#'},
        {'#','#','#','#','#','#','#','#','#','#','#','#','#','#','#'},
        {'#','.','#','.','#','.','#','.','#','.','#','.','#','.','#'},
        {'#','#','#','#','#','#','#','#','#','#','#','#','#','#','#'},
        {'#','.','#','.','#','.','#','.','#','.','#','.','#','.','#'},
        {'#','#','#','#','#','#','#','#','#','#','#','#','#','#','#'},
        {'#','.','#','.','#','.','#','.','#','.','#','.','#','.','#'},
        {'#','#','#','#','#','#','#','#','#','#','#','#','#','#','#'},
        {'#','.','#','.','#','.','#','.','#','.','#','.','#','.','#'},
        {'#','#','#','#','#','#','#','#','#','#','#','#','#','#','#'},
                            };
    init_maze();
    bool res = true;
    for(int i = 0; i < width; i++){
        for(int j = 0; j < height; j++){
            if(maze[i][j] != mazeNotTrue[i][j]){
                res = false;
            }
        }
    }
    ASSERT_EQ(res, false);

}

TEST(modalNegativeTest,getNeighbours) {
    char mazeTrue[15][15] = {
        {'#','#','#','#','#','#','#','#','#','#','#','#','#','#','#'},
        {'#','.','#','#','#','.','#','.','#','.','#','.','#','.','#'},
        {'#','#','#','#','#','#','#','#','#','#','#','#','#','#','#'},
        {'#','#','#','.','#','.','#','.','#','.','#','.','#','.','#'},
        {'#','#','#','#','#','#','#','#','#','#','#','#','#','#','#'},
        {'#','.','#','.','#','.','#','.','#','.','#','.','#','.','#'},
        {'#','#','#','#','#','#','#','#','#','#','#','#','#','#','#'},
        {'#','.','#','.','#','.','#','.','#','.','#','.','#','.','#'},
        {'#','#','#','#','#','#','#','#','#','#','#','#','#','#','#'},
        {'#','.','#','.','#','.','#','.','#','.','#','.','#','.','#'},
        {'#','#','#','#','#','#','#','#','#','#','#','#','#','#','#'},
        {'#','.','#','.','#','.','#','.','#','.','#','.','#','.','#'},
        {'#','#','#','#','#','#','#','#','#','#','#','#','#','#','#'},
        {'#','.','#','.','#','.','#','.','#','.','#','.','#','.','#'},
        {'#','#','#','#','#','#','#','#','#','#','#','#','#','#','#'},
                            };
    cellString test = getNeighbours(mazeTrue, {1,1});
    bool res = true;
    if(test.size != 0){
        res = false;
    }
    ASSERT_EQ(res,1);
}

TEST(modalNegativeTest,movementPlayerW) {
    for(int i = 0; i < height; i++){
            for(int j = 0; j < width; j++){
                if(j == 0 || j == 14 || i == 0 || i == 14){
                    maze[i][j] = WALL;
                }
                else maze[i][j] = VISITED;
            }
        }
    igrok.current_player_pos = {1,1};

    maze[igrok.current_player_pos.x][igrok.current_player_pos.y] = '@';
    movementPlayer(119);
    int res = 0;
    if(igrok.current_player_pos.x == 1 && igrok.current_player_pos.y == 1){
        res = 1;
    }

    ASSERT_EQ(res,1);
}

TEST(modalNegativeTest,movementPlayerD) {
    for(int i = 0; i < height; i++){
            for(int j = 0; j < width; j++){
                if(j == 0 || j == 14 || i == 0 || i == 14){
                    maze[i][j] = WALL;
                }
                else maze[i][j] = VISITED;
            }
        }
    igrok.current_player_pos = {1,13};

    maze[igrok.current_player_pos.x][igrok.current_player_pos.y] = '@';
    movementPlayer(100);
    int res = 0;
    if(igrok.current_player_pos.x == 1 && igrok.current_player_pos.y == 13){
        res = 1;
    }

    ASSERT_EQ(res,1);
}

TEST(modalNegativeTest,movementPlayerA) {
    for(int i = 0; i < height; i++){
            for(int j = 0; j < width; j++){
                if(j == 0 || j == 14 || i == 0 || i == 14){
                    maze[i][j] = WALL;
                }
                else maze[i][j] = VISITED;
            }
        }
    igrok.current_player_pos = {1,1};

    maze[igrok.current_player_pos.x][igrok.current_player_pos.y] = '@';
    movementPlayer(97);
    int res = 0;
    if(igrok.current_player_pos.x == 1 && igrok.current_player_pos.y == 1){
        res = 1;
    }

    ASSERT_EQ(res,1);
}

TEST(modalNegativeTest,movementPlayerS) {
    for(int i = 0; i < height; i++){
            for(int j = 0; j < width; j++){
                if(j == 0 || j == 14 || i == 0 || i == 14){
                    maze[i][j] = WALL;
                }
                else maze[i][j] = VISITED;
            }
        }
    igrok.current_player_pos = {13,1};

    maze[igrok.current_player_pos.x][igrok.current_player_pos.y] = '@';
    movementPlayer(115);
    int res = 0;
    if(igrok.current_player_pos.x == 13 && igrok.current_player_pos.y == 1){
        res = 1;
    }

    ASSERT_EQ(res,1);
}





#endif // TEST_H
